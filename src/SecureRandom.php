<?php

namespace Riimu\Kit\SecureRandom;

use Riimu\Kit\SecureRandom\Generator\Generator;

/**
 * Library for normalizing bytes returned by secure random byte generators.
 *
 * SecureRandom takes bytes generated by secure random byte generators and
 * normalizes (i.e. provides even distribution) for other common usages, such
 * as generation of integers, floats and randomizing arrays.
 *
 * @author Riikka Kalliomäki <riikka.kalliomaki@gmail.com>
 * @copyright Copyright (c) 2014, Riikka Kalliomäki
 * @license http://opensource.org/licenses/mit-license.php MIT License
 */
class SecureRandom
{
    /**
     * The random byte generator.
     * @var Generator
     */
    private $generator;

    /**
     * Buffered bytes for generating additional integers.
     * @var string
     */
    private $buffer;

    /**
     * The number of usable bytes needed the be generated.
     * @var integer
     */
    private $bytesNeeded;

    /**
     * Creates a new instance of SecureRandom.
     *
     * You can either provide a generator to use for generating random bytes or
     * give null as the argument to use default generators. If null is provided,
     * the constructor will attempt to create the random byte generators in the
     * following order until it finds one that is supported:
     *
     *  - RandomReader
     *  - Mcrypt
     *  - OpenSSL
     *
     * Note that since most cases require non-blocking random generation, the
     * default generators use /dev/urandom as the random source. If you do not
     * think this provides enough security, create the desired random generator
     * using /dev/random as the source.
     *
     * @param Generator $generator The generator to use for generating random bytes
     * @throws GeneratorException If the provided or default generators are not supported
     */
    public function __construct(Generator $generator = null)
    {
        $this->generator = $generator;

        if ($this->generator === null) {
            $generators = [
                '\Riimu\Kit\SecureRandom\Generator\RandomReader',
                '\Riimu\Kit\SecureRandom\Generator\Mcrypt',
                '\Riimu\Kit\SecureRandom\Generator\OpenSSL',
            ];

            foreach ($generators as $generator) {
                $this->generator = new $generator;

                if ($this->generator->isSupported()) {
                    break;
                }
            }
        }

        if (!$this->generator->isSupported()) {
            throw new GeneratorException('No supported secure random byte generator available');
        }
    }

    /**
     * Returns a number of random bytes.
     * @param integer $count Number of random bytes to return
     * @return string Randomly generated bytes
     * @throws \InvalidArgumentException If the count is invalid
     */
    public function getBytes($count)
    {
        $count = (int) $count;

        if ($count < 0) {
            throw new \InvalidArgumentException('Number of bytes must be 0 or more');
        } elseif ($count === 0) {
            return '';
        }

        return $this->generator->getBytes($count);
    }

    /**
     * Returns a random integer between two positive integers (inclusive).
     * @param integer $min Minimum limit
     * @param integer $max Maximum limit
     * @return integer Random integer between minimum and maximum limit
     * @throws \InvalidArgumentException If the limits are invalid
     */
    public function getInteger($min, $max)
    {
        $min = (int) $min;
        $max = (int) $max;

        if ($min < 0 || $max < $min) {
            throw new \InvalidArgumentException('Invalid minimum or maximum value');
        }

        $this->setBuffer(floor(log($max - $min, 256)) + 1);
        return $min + $this->getBufferedInt($max - $min);
    }

    /**
     * Returns a random float between 0 and 1 (inclusive).
     * @return float Random float between 0 and 1
     */
    public function getFloat()
    {
        return (float) ($this->getInteger(0, PHP_INT_MAX) / PHP_INT_MAX);
    }

    /**
     * Returns a number of randomly selected elements from the array.
     *
     * This method returns randomly selected elements from the array. The number
     * of elements is determined by by the second argument. The elements are
     * returned in random order but the keys are preserved.
     *
     * @param array $array Array of elements
     * @param integer $count Number of elements to return from the array
     * @return array Randomly selected elements in random order
     * @throws \InvalidArgumentException If the count is invalid
     */
    public function getArray(array $array, $count)
    {
        $count = (int) $count;
        $size = count($array);

        if ($count < 0 || $count > $size) {
            throw new \InvalidArgumentException('Invalid number of elements');
        }

        $this->setBuffer($count === 0 ? 0 : $this->countBytesNeeded($size - 1, $size - $count));
        $result = [];

        for ($i = 0; $i < $count; $i++) {
            $element = array_slice($array, $this->getBufferedInt($size - $i - 1), 1, true);
            $result += $element;
            unset($array[key($element)]);
        }

        return $result;
    }

    /**
     * Returns one randomly selected value from the array.
     * @param array $array Array to choose from
     * @return mixed One randomly selected value from the array
     * @throws \InvalidArgumentException If the array is empty
     */
    public function choose(array $array)
    {
        if ($array === []) {
            throw new \InvalidArgumentException('Array must have at least one value');
        }

        return current(array_slice($array, $this->getInteger(0, count($array) - 1), 1));
    }

    /**
     * Returns the array with the elements reordered in random order.
     * @param array $array Array to shuffle
     * @return array The provided array with elements in random order
     */
    public function shuffle(array $array)
    {
        return $this->getArray($array, count($array));
    }

    /**
     * Returns a random sequence of values.
     *
     * If a string is provided as the first argument, the method returns a
     * string with characters selected from the provided string. The length of
     * the returned string is determined by the second argument.
     *
     * If an array is provided as the first argument, the method returns an
     * array with elements selected from the provided array. The size of the
     * returned array is determined by the second argument.
     *
     * The functionality is similar to getArray(), except for the fact that the
     * returned value can contain the same character or element multiple times.
     * If the same character or element appears multiple times in the provided
     * argument, it will increase the relative chance of it appearing in the
     * returned value.
     *
     * @param string|array $choices Values to choose from
     * @param integer $length Length of the sequence
     * @return array|string The generated random sequence
     * @throws \InvalidArgumentException If the choices or length is invalid
     */
    public function getSequence($choices, $length)
    {
        $length = (int) $length;
        $values = is_array($choices) ? array_values($choices) : str_split($choices);
        $count = count($values);

        if ($length < 0) {
            throw new \InvalidArgumentException('Sequence length must be at least 0');
        } elseif ($count < 1) {
            throw new \InvalidArgumentException('Must have at least one value to choose from');
        }

        $this->setBuffer((floor(log($count, 256)) + 1) * $length);
        $result = [];

        for ($i = 0; $i < $length; $i++) {
            $result[] = $values[$this->getBufferedInt($count - 1)];
        }

        return is_array($choices) ? $result : implode('', $result);
    }

    /**
     * Counts the number of bytes needed to represent numbers.
     * @param integer $m Largest number to represent
     * @param integer $n Smallest number to represent
     * @return integer The number of bytes needed
     */
    function countBytesNeeded($m, $n)
    {
        $count = $m - $n + 1;
        $bytes = 0;

        for ($i = (int) (floor(log($m, 256)) + 1), $total = 0; $total < $count; $i--) {
            $max = $i === PHP_INT_SIZE ? PHP_INT_MAX : (1 << ($i * 8)) - 1;
            $min = $i === 1 ? -1 : (1 << (($i - 1) * 8)) - 1;

            $numbers = min($count - $total, $m - $min, $max - $min);
            $total += $numbers;
            $bytes += $i * $numbers;
        }

        return $bytes;
    }

    /**
     * Sets the number of bytes to buffer for further generated integers.
     * @param integer $bytesNeeded The minimum number of bytes needed
     */
    private function setBuffer($bytesNeeded)
    {
        $this->buffer = '';
        $this->bytesNeeded = (int) $bytesNeeded;
    }

    /**
     * Returns a random integer between 0 and limit and buffers further reads.
     * @param integer $limit Maximum number to return
     * @return integer A random integer between 0 and limit
     */
    private function getBufferedInt($limit)
    {
        if ($limit === 0) {
            return 0;
        }

        $bits = 1;

        while (($limit >> $bits) > 0) {
            $bits++;
        }

        $bytes = (int) ceil($bits / 8);
        $mask = (int) ((1 << $bits) - 1);

        do {
            if (strlen($this->buffer) < $bytes) {
                $this->buffer .= $this->generator->getBytes($this->bytesNeeded - strlen($this->buffer));
            }

            $result = hexdec(bin2hex(substr($this->buffer, 0, $bytes))) & $mask;
            $this->buffer = substr($this->buffer, $bytes);
        } while ($result > $limit);

        $this->bytesNeeded -= $bytes;

        return $result;
    }
}
