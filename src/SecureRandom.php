<?php

namespace Riimu\Kit\SecureRandom;

use Riimu\Kit\SecureRandom\Generator\Generator;

/**
 * Library for normalizing bytes returned by secure random byte generators.
 *
 * SecureRandom takes bytes generated by secure random byte generators and
 * normalizes (i.e. provides even distribution) for other common usages, such
 * as generation of integers, floats and randomizing arrays.
 *
 * @author Riikka Kalliomäki <riikka.kalliomaki@gmail.com>
 * @copyright Copyright (c) 2014, Riikka Kalliomäki
 * @license http://opensource.org/licenses/mit-license.php MIT License
 */
class SecureRandom
{
    /**
     * The random byte generator.
     * @var Generator
     */
    private $generator;

    /**
     * Creates a new instance of SecureRandom.
     *
     * You can either provide a generator to use for generating random bytes or
     * give null as the argument to use default generators. If null is provided,
     * the constructor will attempt to create the random byte generators in the
     * following order until it finds one that is supported:
     *
     * - RandomReader
     * - Mcrypt
     * - OpenSSL
     *
     * Note that since most cases require non-blocking random generation, the
     * default generators use /dev/urandom as the random source. If you do not
     * think this provides enough security, create the desired random generator
     * using /dev/random as the source.
     *
     * @param Generator $generator The generator to use for generating random bytes
     * @throws GeneratorException If the provided or default generators are not supported
     */
    public function __construct(Generator $generator = null)
    {
        $this->generator = $generator;

        if ($this->generator === null) {
            $generators = [
                '\Riimu\Kit\SecureRandom\Generator\RandomReader',
                '\Riimu\Kit\SecureRandom\Generator\Mcrypt',
                '\Riimu\Kit\SecureRandom\Generator\OpenSSL',
            ];

            foreach ($generators as $generator) {
                $this->generator = new $generator;

                if ($this->generator->isSupported()) {
                    break;
                }
            }
        }

        if (!$this->generator->isSupported()) {
            throw new GeneratorException('No supported secure random byte generator available');
        }
    }

    /**
     * Returns a number of random bytes.
     * @param integer $count Number of random bytes to return
     * @return string Randomly generated bytes
     * @throws \InvalidArgumentException If the count is invalid
     */
    public function getBytes($count)
    {
        $count = (int) $count;

        if ($count < 0) {
            throw new \InvalidArgumentException('Number of bytes must be 0 or more');
        } elseif ($count === 0) {
            return '';
        }

        return $this->generator->getBytes($count);
    }

    /**
     * Returns a random integer between two positive integers (inclusive).
     * @param integer $min Minimum limit
     * @param integer $max Maximum limit
     * @return integer Random integer between minimum and maximum limit
     * @throws \InvalidArgumentException If the limits are invalid
     */
    public function getInteger($min, $max)
    {
        $min = (int) $min;
        $max = (int) $max;

        if ($min < 0 || $max < $min) {
            throw new \InvalidArgumentException('Invalid minimum or maximum value');
        } elseif ($min === $max) {
            return $min;
        }

        $diff = $max - $min;

        for ($bits = 1, $mask = 1; $diff >> $bits > 0; $bits++) {
            $mask |= 1 << $bits;
        }

        $bytes = (int) ceil($bits / 8);

        do {
            $result = hexdec(bin2hex($this->generator->getBytes($bytes))) & $mask;
        } while ($result > $diff);

        return $min + $result;
    }

    /**
     * Returns a random float between 0 and 1 (inclusive).
     * @return float Random float between 0 and 1
     */
    public function getFloat()
    {
        return (float) ($this->getInteger(0, PHP_INT_MAX) / PHP_INT_MAX);
    }

    /**
     * Returns a number of randomly selected elements from the array.
     *
     * This method returns randomly selected elements from the array. The number
     * of elements is determined by by the second argument. The elements are
     * returned in random order but the keys are preserved.
     *
     * @param array $array Array of elements
     * @param integer $count Number of elements to return from the array
     * @return array Randomly selected elements in random order
     * @throws \InvalidArgumentException If the count is invalid
     */
    public function getArray(array $array, $count)
    {
        $count = (int) $count;
        $size = count($array);

        if ($count < 0 || $count > $size) {
            throw new \InvalidArgumentException('Invalid number of elements');
        }

        $result = [];

        for ($i = 0; $i < $count; $i++) {
            $element = array_slice($array, $this->getInteger(0, $size - $i - 1), 1, true);
            $result += $element;
            unset($array[key($element)]);
        }

        return $result;
    }

    /**
     * Returns one randomly selected value from the array.
     * @param array $array Array to choose from
     * @return mixed One randomly selected value from the array
     * @throws \InvalidArgumentException If the array is empty
     */
    public function choose(array $array)
    {
        if ($array === []) {
            throw new \InvalidArgumentException('Array must have at least one value');
        }

        return current(array_slice($array, $this->getInteger(0, count($array) - 1), 1));
    }

    /**
     * Returns the array with the elements reordered in random order.
     * @param array $array Array to shuffle
     * @return array The provided array with elements in random order
     */
    public function shuffle(array $array)
    {
        return $this->getArray($array, count($array));
    }

    /**
     * Returns a random sequence of values.
     *
     * If a string is provided as the first argument, the method returns a
     * string with characters selected from the provided string. The length of
     * the returned string is determined by the second argument.
     *
     * If an array is provided as the first argument, the method returns an
     * array with elements selected from the provided array. The size of the
     * returned array is determined by the second argument.
     *
     * The functionality is similar to getArray(), except for the fact that the
     * returned value can contain the same character or element multiple times.
     * If the same character or element appears multiple times in the provided
     * argument, it will increase the relative chance of it appearing in the
     * returned value.
     *
     * @param string|array $choices Values to choose from
     * @param integer $length Length of the sequence
     * @return array|string The generated random sequence
     * @throws \InvalidArgumentException If the choices or length is invalid
     */
    public function getSequence($choices, $length)
    {
        $length = (int) $length;
        $values = is_array($choices) ? array_values($choices) : str_split($choices);
        $count = count($values);

        if ($length < 0) {
            throw new \InvalidArgumentException('Sequence length must be at least 0');
        } elseif ($count < 1 && $length > 0) {
            throw new \InvalidArgumentException('Must have at least one value to choose from');
        }

        $result = [];

        for ($i = 0; $i < $length; $i++) {
            $result[] = $values[$this->getInteger(0, $count - 1)];
        }

        return is_array($choices) ? $result : implode('', $result);
    }
}
